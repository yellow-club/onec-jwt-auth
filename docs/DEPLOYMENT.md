# Деплой и публикации (2× default.vrd)

В этом проекте intentionally используются **две публикации** одной и той же ИБ:

1) **Публикация AUTH** — выдача JWT по PAT/Basic
2) **Публикация API** — бизнесовые HTTP-сервисы, закрытые JWT на периметре

Почему так: у публикации API включён `<accessTokenAuthentication>`, а для выдачи токена это не нужно (и мешает).

> JWT-аутентификация платформы доступна только для опубликованных ИБ.

---

## 0) Перед началом

### Версия платформы
- Минимально поддерживаемая: **8.3.27.1936**


### Ключи (RS256)

Для RS256 нужна **пара** ключей в формате PEM:

- **`jwt_private.pem`** — закрытый ключ для подписи JWT *внутри 1С*  
  Хранится в константе `СекретныйКлючПодписиJWT`. Рекомендуемый путь загрузки: обработка **`Тестирование` → «Добавить секретный ключ»**.
- **`jwt_public.pem`** — публичный ключ для проверки подписи JWT *на периметре*  
  Его нужно указать в `default.vrd` публикации **API** (атрибут `keyInformation`).

Пример генерации через OpenSSL:

```bash
# private key (RSA 2048)
openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:2048 -out jwt_private.pem

# public key из private
openssl pkey -in jwt_private.pem -pubout -out jwt_public.pem
```

> В `keyInformation` для HS* алгоритмов хранится симметричный ключ, а для RS256 — **публичный** ключ.

---

## 1) Публикация AUTH (выдача JWT)

Цель: разрешить `POST /hs/auth/token` по PAT/Basic.

Что делать:

1) Создайте **отдельную** веб‑публикацию для выдачи токена (например, `/auth`).
2) Возьмите файл `deploy/vrd/auth.default.vrd.example`, скопируйте в папку публикации и переименуйте в **`default.vrd`**.
3) Внутри `default.vrd` заполните `TODO:IB` (путь к базе / строка соединения).

Важно:
- В AUTH‑публикации **не должно быть** `<accessTokenAuthentication>` — иначе получится «токен нужен, чтобы получить токен».
- PAT/Basic проверяются логикой конфигурации, без участия `default.vrd`.

Рекомендации:
- ограничьте доступ к публикации (VPN / IP allowlist / внутренний контур)
- включите HTTPS


---

## 2) Публикация API (боевые эндпойнты, Bearer JWT)

Цель: закрыть боевые HTTP‑сервисы JWT аутентификацией на периметре (проверка подписи/iss/aud/exp до входа в код 1С).

Что делать:

1) Создайте **отдельную** веб‑публикацию для боевого API (например, `/api`).
2) Возьмите файл `deploy/vrd/api.default.vrd.example`, скопируйте в папку публикации и переименуйте в **`default.vrd`**.
3) Заполните в нём:
   - `TODO:IB` — путь к базе / строка соединения
   - `TODO:AUD` — то, что ожидаете в claim `aud`
   - `TODO:ISS` — то, что ожидаете в claim `iss`
   - `PUBLIC KEY` в `issuer/@keyInformation` — содержимое `jwt_public.pem`

По умолчанию этот проект рассчитан на технического пользователя:
- `sub` в JWT содержит имя пользователя (например, `jwt_service`)
- в ИБ должен существовать пользователь с `Name = jwt_service`
  (это следует из `authenticationClaimName="sub"` и `authenticationUserPropertyName="name"` в VRD)

> Если вы добавляете новые HTTP‑сервисы — перечисляйте их отдельными `<service ...>` внутри `<httpServices>`.


---

## 3) Что должно совпасть: конфигурация ↔ default.vrd

Платформа сверяет поля JWT с настройками публикации:

- `aud` (в payload) ↔ `<accessTokenRecepientName>`
- `iss` (в payload) ↔ `issuer/@name`
- `sub` (в payload) ↔ пользователь ИБ, если используете
  `authenticationClaimName="sub"` + `authenticationUserPropertyName="name"`

Также публичный ключ в `default.vrd` (API‑публикация) должен соответствовать private key,
который используется для подписи JWT в конфигурации (загружается через обработку **«Тестирование» → «Добавить секретный ключ»**).

Если вы меняете `aud/iss/sub` — делайте это **согласованно**:
- в конфигурации (политика/константы, которые формируют JWT)
- в `default.vrd` (API‑публикация)


---

## 4) Две публикации — два набора VRD

Рекомендуем хранить в репозитории шаблоны:
- `deploy/vrd/auth.default.vrd.example`
- `deploy/vrd/api.default.vrd.example`

И дальше поддерживать их как “живую документацию”.

